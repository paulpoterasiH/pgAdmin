<?$output = false;require_once("../system/security.php");require_once($sys_folder."/libs/phpDB.php");require_once($sys_folder."/libs/phpDBLib.php");require("dbLib.php");$lstParams = js_unescape($cmd);if ($lstParams['db'] == '') $lstParams['db'] = 'template1';$tmp = split(":", $_SESSION['ses_database']);$sys_dbType 	= 'postgres';$sys_dbIP		= $tmp[0];$sys_dbPort		= $tmp[1]; $sys_dbLogin	= $tmp[2];$sys_dbPass		= $tmp[3];$sys_dbName		= $lstParams['db'];$db = new phpDBConnection($sys_dbType);$db->connect($sys_dbIP, $sys_dbLogin, $sys_dbPass, $sys_dbName, $sys_dbPort);require("features.php");switch ($lstParams['req_name']."::".$lstParams['req_cmd']) {	case "funScript::edit_get_data":		print("top.elements['funScript'].dataReceived();");		break;		case "funPriv::lst_get_data":		$tmp = split("::", $lstParams['fun']); 		$funoid = $tmp[1];		// -- table rules		$sql = "SELECT proacl FROM pg_proc WHERE oid = $funoid";		$rs  = $db->execute($sql);		$sql = "";		while ($rs && !$rs->EOF) {			$tmp = split(',', trim(trim($rs->fields[0], '{'), '}'));			foreach ($tmp as $k => $v) {				$t    = split('=', $v);				$tt   = split('/', $t[1]);				if ($sql != '') $sql .= " UNION ALL ";				$rights = "";				if (strpos($tt[0], 'r') !== false) $rights .= " SELECT,";				if (strpos($tt[0], 'w') !== false) $rights .= " UPDATE,";				if (strpos($tt[0], 'a') !== false) $rights .= " INSERT,";				if (strpos($tt[0], 'd') !== false) $rights .= " DELETE,";				if (strpos($tt[0], 'x') !== false) $rights .= " REFERENCES,";				if (strpos($tt[0], 't') !== false) $rights .= " TRIGGER,";				if (strpos($tt[0], 'X') !== false) $rights .= " EXECUTE,";				if (strpos($tt[0], 'U') !== false) $rights .= " USAGE,";				if (strpos($tt[0], 'C') !== false) $rights .= " CREATE,";				if (strpos($tt[0], 'c') !== false) $rights .= " CONNECT,";				if (strpos($tt[0], 'T') !== false) $rights .= " TEMPORARY,";				if (strpos($tt[0], 'R') !== false) $rights .= " RULE,";				if (strpos($tt[0], '*') !== false) $rights .= "'Preceding privilege'";				if ($rights == "") continue;				$rights = substr($rights, 0, strlen($rights)-1);				$sql .= "(SELECT '".($t[0] != '' ? $t[0] : 'PUBLIC')."', '".($t[0] != '' ? $t[0] : 'PUBLIC')."', '".$rights."', '".$tt[1]."')"; 			}			$rs->moveNext();		}		if ($sql == "") $sql = "SELECT 1 FROM pg_proc WHERE 1=2";		list_process($db, $lstParams, $sql);		break;			case "funPriv::lst_del_records":		$sql = "";		$ids = split(',', $lstParams['req_ids']);		foreach($ids as $k => $v) {			$t = split('::', $lstParams['fun']); 			$sql .= "REVOKE ALL PRIVILEGES ON FUNCTION ".$t[0]." FROM $v;\\n";		}		print("top.execCommand(\"".$sql."\", 'top.elements.funPriv.output();');");		break;			case "funPrivAdd::edit_get_data":		$sql = "SELECT null"; 		edit_process($db, $lstParams, $sql);		break;			case "funPrivAdd::edit_field_list":		$sql = "SELECT 'PUBLIC', 'PUBLIC'				UNION ALL				(SELECT usename, usename FROM  pg_user ORDER BY usename)				UNION ALL				(SELECT 'GROUP ' || groname, 'GROUP: ' || groname FROM  pg_group ORDER BY groname)";		buildOptions($db, $lstParams, $sql);		break;			case "funPrivAdd::edit_save_data":		$p = $_POST;		$t = split('::', $lstParams['fun']);		$sql = "REVOKE ALL ON FUNCTION ".$t[0]." FROM ".$p['user'].";\\n";		if ($p['execute'] == 't') 	$sql .= "GRANT EXECUTE ON FUNCTION ".$t[0]." TO ".$p['user'].";\\n";		if ($p['all'] == 't') 		$sql  = "GRANT ALL ON FUNCTION ".$t[0]." TO ".$p['user'].";\\n";		print("<script>top.execCommand(\"".$sql."\", 'top.elements.funPriv.output();');</script>");		break;			default:		print("alert('List command is not recognized:  ".$lstParams['req_name']."::".$lstParams['req_cmd']."');");		break;}switch ($cmd) {	case "get_script":		$db = new phpDBConnection($sys_dbType);		$db->connect($sys_dbIP, $sys_dbLogin, $sys_dbPass, $_GET['db']);				$tmp = split('\.', $fun);		$fun = split('::', $tmp[2]);		$funoid = $fun[1];		$db->debug = true;		$sql = "SELECT proname, typname, lanname, oidvectortypes(proargtypes), prosrc, proisstrict, prosecdef, 					provolatile, proretset			    FROM pg_proc, pg_namespace, pg_language, pg_type			    WHERE pronamespace != 11					AND pg_proc.pronamespace = pg_namespace.oid					AND prolang = pg_language.oid					AND prorettype = pg_type.oid					AND pg_proc.oid = $funoid";								$rs = $db->Execute($sql);		if (!$rs->EOF) {			$fn 		= $rs->fields[0];			$type	 	= $rs->fields[1];			$lang 		= $rs->fields[2];			$args		= $rs->fields[3];			$src		= str_replace("'", "\\'", $rs->fields[4]);			$rn 		= $rs->fields[5];			$ex 		= $rs->fields[6];			$prov 		= $rs->fields[7];			$isSetOf 	= $rs->fields[8];		}		//print_r($rs->fields);				if ($rn == 't') $rn = "RETURNS NULL"; else $rn = "CALLED";		if ($imm == 't') $repl = "IMMUTABLE";		if ($stab == 't') $repl = "STABLE";		if ($prov == 'v') $repl = "VOLATILE"; elseif ($prov == 'i')	$repl = "IMMUTABLE"; else $repl = "STABLE";		if ($ex == 't') $ex = "DEFINER"; else $ex = "INVOKER";		if ($isSetOf == 't') $isSetOf = 'SETOF '; else $isSetOf = '';				$sql =  "CREATE OR REPLACE FUNCTION $tmp[0].$tmp[1].$fn($args)\n".				"    RETURNS $isSetOf$type\n".				"    $rn ON NULL INPUT\n".				"    $repl\n".				"    SECURITY $ex\n".				"    LANGUAGE $lang\n".				"AS\n\n".			    "'$src';";				print("<textarea id=sql>$sql</textarea>");		print("<script>parent.document.getElementById('sql').value = document.getElementById('sql').value;</script>");		break;}?>